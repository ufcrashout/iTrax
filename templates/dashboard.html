{% extends "base.html" %}

{% block title %}Dashboard - iTrax{% endblock %}

{% block extra_css %}
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        /* Dashboard specific styles */
        .card {
            border: none;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            transition: transform 0.3s ease;
        }
        .card:hover {
            transform: translateY(-2px);
        }
        .card-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px 15px 0 0 !important;
            border: none;
        }
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 10px;
            padding: 0.5rem 1.5rem;
        }
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        #map {
            height: 500px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .stats-card {
            background: white;
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }
        .stats-number {
            font-size: 2rem;
            font-weight: 700;
            color: #667eea;
        }
        .stats-label {
            color: #6c757d;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .device-list {
            max-height: 300px;
            overflow-y: auto;
        }
        .device-item {
            padding: 0.75rem;
            border-bottom: 1px solid #e9ecef;
            transition: background-color 0.3s ease;
        }
        .device-item:hover {
            background-color: #f8f9fa;
        }
        .device-item:last-child {
            border-bottom: none;
        }
        .alert {
            border-radius: 10px;
            border: none;
        }
        .form-control, .form-select {
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }
        .form-control:focus, .form-select:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
        }
        .loading {
            display: none;
            text-align: center;
            padding: 2rem;
        }
        .spinner-border {
            color: #667eea;
        }
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .status-active {
            background-color: #28a745;
        }
        .status-inactive {
            background-color: #dc3545;
        }
        .no-data-message {
            margin-top: 10px;
            z-index: 1000;
        }
        
        /* Notification Styles */
        .notification-dropdown {
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border: none;
            border-radius: 10px;
        }
        .notification-item {
            border-left: 4px solid #007bff;
            margin: 0.5rem;
            padding: 0.75rem;
            border-radius: 0 8px 8px 0;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .notification-item:hover {
            background-color: #f8f9fa;
            transform: translateX(2px);
        }
        .notification-item.unread {
            background-color: #e3f2fd;
            border-left-color: #2196f3;
        }
        .notification-item.read {
            opacity: 0.7;
            border-left-color: #6c757d;
        }
        .notification-item.priority-high {
            border-left-color: #ff9800;
        }
        .notification-item.priority-urgent {
            border-left-color: #f44336;
            animation: pulse-urgent 2s infinite;
        }
        .notification-geofence {
            border-left-color: #4caf50;
        }
        .notification-device {
            border-left-color: #9c27b0;
        }
        .notification-system {
            border-left-color: #607d8b;
        }
        @keyframes pulse-urgent {
            0% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(244, 67, 54, 0); }
            100% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0); }
        }
        .notification-badge-animate {
            animation: bounce 0.5s;
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-5px); }
            60% { transform: translateY(-3px); }
        }
        
        /* Mobile Responsive Styles */
        @media (max-width: 991.98px) {
            .navbar-nav {
                padding: 1rem 0;
            }
            .navbar-nav .nav-link {
                padding: 0.75rem 1rem;
                border-bottom: 1px solid rgba(255,255,255,0.1);
            }
            .navbar-nav .nav-link:last-child {
                border-bottom: none;
            }
            .notification-dropdown {
                min-width: 300px !important;
                max-width: 320px !important;
            }
            .navbar-text {
                padding: 0.75rem 1rem;
                border-top: 1px solid rgba(255,255,255,0.1);
                margin: 0 !important;
            }
        }
        
        @media (max-width: 767.98px) {
            #map {
                height: 300px;
            }
            .main-content {
                padding: 1rem 0;
            }
            .stats-card {
                margin-bottom: 0.75rem;
                padding: 1rem;
            }
            .stats-number {
                font-size: 1.75rem;
            }
            .card {
                margin-bottom: 1rem;
            }
            .notification-dropdown {
                min-width: 280px !important;
                max-width: 300px !important;
                margin-right: -1rem;
            }
        }
        
        @media (max-width: 575.98px) {
            .container {
                padding-left: 1rem;
                padding-right: 1rem;
            }
            #map {
                height: 250px;
            }
            .stats-number {
                font-size: 1.5rem;
            }
            .notification-dropdown {
                min-width: 260px !important;
                max-width: 280px !important;
                margin-right: -1.5rem;
            }
            .btn {
                padding: 0.625rem 1.25rem;
                font-size: 0.875rem;
            }
            .card-header h5, .card-header h6 {
                font-size: 1rem;
            }
            /* Touch-friendly form elements */
            .form-control, .form-select, .btn {
                min-height: 44px;
            }
        }
        
        /* Touch optimizations for map */
        .leaflet-container {
            font-size: 14px;
        }
        
        /* Visit Details Tabs Styles */
        .nav-tabs {
            border-bottom: 2px solid #e9ecef;
        }
        
        .nav-tabs .nav-link {
            color: #495057 !important;
            background-color: #ffffff !important;
            border: 2px solid #dee2e6 !important;
            border-bottom: none !important;
            border-radius: 10px 10px 0 0 !important;
            transition: all 0.3s ease;
            margin-right: 0.25rem;
            font-weight: 600;
            padding: 0.75rem 1.25rem;
            text-decoration: none;
        }
        
        .nav-tabs .nav-link:hover {
            border-color: #667eea #667eea #e9ecef #667eea !important;
            background-color: #f8f9ff !important;
            color: #667eea !important;
        }
        
        .nav-tabs .nav-link.active {
            color: #ffffff !important;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            border-color: #667eea #667eea #e9ecef #667eea !important;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
            position: relative;
            z-index: 1;
        }
        
        .nav-tabs .nav-link .badge {
            background-color: rgba(102, 126, 234, 0.2) !important;
            color: #495057 !important;
            font-size: 0.75rem;
        }
        
        .nav-tabs .nav-link.active .badge {
            background-color: rgba(255, 255, 255, 0.9) !important;
            color: #667eea !important;
        }
        
        .visit-item {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .visit-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-color: #667eea;
        }
        
        .visit-location {
            font-weight: 600;
            color: #333;
            margin-bottom: 0.5rem;
        }
        
        .visit-times {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .visit-time-item {
            background: #f8f9fa;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .visit-time-item.arrival {
            background: #d4edda;
            color: #155724;
        }
        
        .visit-time-item.departure {
            background: #f8d7da;
            color: #721c24;
        }
        
        .visit-time-item.duration {
            background: #cce5ff;
            color: #004085;
        }
        
        .visit-coordinates {
            font-size: 0.75rem;
            color: #6c757d;
            font-family: monospace;
        }
        
        .driving-segment {
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
            border: 1px solid #e17055;
            border-radius: 10px;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .driving-icon {
            background: white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #e17055;
            font-size: 1.1rem;
            flex-shrink: 0;
        }
        
        .driving-details {
            flex-grow: 1;
        }
        
        .driving-route {
            font-weight: 600;
            color: #2d3436;
            margin-bottom: 0.25rem;
        }
        
        .driving-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.875rem;
            color: #636e72;
        }
        
        .driving-stat {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .tab-content {
            max-height: 400px;
            overflow-y: auto;
        }
        
        @media (max-width: 767.98px) {
            .visit-times {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .nav-tabs {
                flex-wrap: nowrap;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .nav-tabs .nav-link {
                white-space: nowrap;
                min-width: 120px;
            }
        }
        
        .leaflet-control-zoom a {
            width: 36px;
            height: 36px;
            line-height: 36px;
            font-size: 18px;
        }
        
        .leaflet-touch .leaflet-control-attribution {
            font-size: 11px;
        }
        
        /* Improved notification dropdown for mobile */
        @media (max-width: 991.98px) {
            .notification-dropdown .dropdown-header button {
                font-size: 0.75rem;
                padding: 0.25rem 0.5rem;
            }
        }
    </style>
{% endblock %}
{% block content %}

        <!-- Stats Cards -->
        <div class="row mb-4">
            <div class="col-sm-6 col-lg-3 mb-3 mb-lg-0">
                <div class="stats-card text-center">
                    <div class="stats-number" id="total-locations">{{ stats.total_locations if stats else 0 }}</div>
                    <div class="stats-label">Total Locations</div>
                </div>
            </div>
            <div class="col-sm-6 col-lg-3 mb-3 mb-lg-0">
                <div class="stats-card text-center">
                    <div class="stats-number" id="unique-devices">{{ stats.unique_devices if stats else 0 }}</div>
                    <div class="stats-label">Devices Tracked</div>
                </div>
            </div>
            <div class="col-sm-6 col-lg-3 mb-3 mb-lg-0">
                <div class="stats-card text-center">
                    <div class="stats-number" id="last-update">
                        {% if stats and stats.last_update %}
                            {{ stats.last_update | user_timezone }}
                        {% else %}
                            N/A
                        {% endif %}
                    </div>
                    <div class="stats-label">Last Update</div>
                </div>
            </div>
            <div class="col-sm-6 col-lg-3">
                <div class="stats-card text-center">
                    <div class="stats-number" id="today-count">
                        {{ stats.today_count if stats else 0 }}
                    </div>
                    <div class="stats-label">Active Today</div>
                </div>
            </div>
        </div>

        <!-- Movement Tracking Filter -->
        <div class="card mb-4">
            <div class="card-header">
                <h5 class="mb-0"><i class="fas fa-route me-2"></i>24-Hour Movement Tracking</h5>
            </div>
            <div class="card-body">
                <form method="get" action="{{ url_for('dashboard') }}" id="movementForm">
                    <div class="row align-items-end">
                        <div class="col-md-4 mb-3 mb-md-0">
                            <label for="date" class="form-label">
                                <i class="fas fa-calendar me-1"></i>Select Date
                            </label>
                            <input type="date" class="form-control" id="date" name="date" 
                                   value="{{ selected_date or '' }}"
                                   max="{{ get_cst_now().strftime('%Y-%m-%d') }}">
                            <div class="form-text">Shows 24-hour movement from 00:00 to 23:59</div>
                        </div>
                        <div class="col-md-4 mb-3 mb-md-0">
                            <label for="device" class="form-label">
                                <i class="fas fa-mobile-alt me-1"></i>Device Filter
                            </label>
                            <select class="form-select" id="device" name="device">
                                <option value="">All Devices</option>
                                {% for device in available_devices %}
                                    <option value="{{ device.device_name }}" 
                                            {{ 'selected' if selected_device == device.device_name else '' }}>
                                        {{ device.display_name }}
                                    </option>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="col-md-4">
                            <div class="d-grid d-md-block">
                                <button type="submit" class="btn btn-primary mb-2 mb-md-0 me-md-2">
                                    <i class="fas fa-search me-1"></i>View Movement
                                </button>
                                <a href="{{ url_for('dashboard') }}" class="btn btn-outline-secondary mb-2 mb-md-0 me-md-1">
                                    <i class="fas fa-home me-1"></i>Today
                                </a>
                                <button type="button" class="btn btn-outline-info" onclick="setYesterday()">
                                    <i class="fas fa-arrow-left me-1"></i>Yesterday
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Movement Summary -->
                    {% if selected_date or selected_device %}
                    <div class="row mt-3">
                        <div class="col-12">
                            <div class="alert alert-info">
                                <i class="fas fa-info-circle me-2"></i>
                                <strong>Viewing:</strong> 
                                {% if selected_date %}
                                    24-hour movement for {{ selected_date }}
                                {% else %}
                                    Last 24 hours of movement
                                {% endif %}
                                {% if selected_device %}
                                    for device "{{ selected_device }}"
                                {% else %}
                                    for all devices
                                {% endif %}
                                <small class="d-block mt-1 text-muted">
                                    <i class="fas fa-lightbulb me-1"></i>
                                    Locations are clustered to avoid too many pins in the same area. 
                                    Only significant movements (~50+ meters) are shown.
                                </small>
                            </div>
                        </div>
                    </div>
                    {% endif %}
                </form>
            </div>
        </div>

        <div class="row">
            <!-- Map -->
            <div class="col-lg-8 mb-4 mb-lg-0">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0"><i class="fas fa-map me-2"></i>Device Locations</h5>
                    </div>
                    <div class="card-body p-0">
                        <div id="map"></div>
                    </div>
                </div>
            </div>

            <!-- Device List -->
            <div class="col-lg-4">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0"><i class="fas fa-mobile-alt me-2"></i>Tracked Devices</h5>
                    </div>
                    <div class="card-body">
                        <div class="device-list" id="device-list">
                            {% set devices = location_history|map(attribute='device_name')|unique %}
                            {% for device in devices %}
                                <div class="device-item">
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div>
                                            {% set is_offline = offline_devices and (device in offline_devices) %}
                                            <span class="status-indicator {{ 'status-inactive' if is_offline else 'status-active' }}"></span>
                                            <i class="fas fa-mobile-alt me-2 text-primary"></i>
                                            <strong>{{ device | device_display_name }}</strong>
                                        </div>
                                        {% if is_offline %}
                                            <span class="badge bg-danger">Offline</span>
                                        {% else %}
                                            <span class="badge bg-success">Active</span>
                                        {% endif %}
                                    </div>
                                    <small class="text-muted">
                                        {% set device_locations = location_history|selectattr('device_name', 'equalto', device)|list %}
                                        {{ device_locations|length }} locations
                                    </small>
                                    <div class="small text-muted mt-1" id="device-addr-{{ device | replace(' ', '-') | replace('.', '-') | replace("'", '-') | replace('/', '-') }}">
                                        
                                    </div>
                                </div>
                            {% else %}
                                <div class="text-center text-muted py-3">
                                    <i class="fas fa-info-circle fa-2x mb-2"></i>
                                    <p>No devices found</p>
                                </div>
                            {% endfor %}
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Device Visit Details Tabs -->
        <div class="row mt-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0"><i class="fas fa-map-marked-alt me-2"></i>Daily Visit Details</h5>
                    </div>
                    <div class="card-body">
                        <!-- Tab Navigation -->
                        <ul class="nav nav-tabs" id="deviceTabs" role="tablist">
                            <!-- Device tabs will be populated by JavaScript -->
                        </ul>
                        
                        <!-- Tab Content -->
                        <div class="tab-content mt-3" id="deviceTabContent">
                            <!-- Visit details will be populated by JavaScript -->
                        </div>
                        
                        <!-- No Data Message -->
                        <div id="noVisitData" class="text-center text-muted py-4" style="display: none;">
                            <i class="fas fa-info-circle fa-2x mb-2"></i>
                            <p>No visit data available for the selected period.</p>
                            <small>Select a date and device to view detailed visit information.</small>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Loading Indicator -->
        <div class="loading" id="loading">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Loading location data...</p>
        </div>
{% endblock %}

    

{% block extra_js %}
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Performance optimized map initialization
        var locations = {{ location_history | tojson }};
        var userSettings = {{ user_settings | tojson | safe }} || {
            timezone: 'America/Chicago',
            date_format: '%Y-%m-%d %I:%M:%S %p',
            theme: 'light',
            map_default_zoom: 10,
            refresh_interval: 300
        };
        var markers = [];
        var polylines = [];
        var deviceColors = {};
        var colorPalette = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#5F27CD'];
        var colorIndex = 0;
        var map;
        var markersLayer;
        
        // Timezone utility function
        function formatTimestampForUser(timestamp) {
            try {
                const date = new Date(timestamp);
                const options = {
                    timeZone: userSettings.timezone || 'America/Chicago',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: userSettings.date_format ? userSettings.date_format.includes('%I') : true
                };
                
                return new Intl.DateTimeFormat('en-US', options).format(date);
            } catch (error) {
                console.error('Error formatting timestamp:', error);
                return timestamp;
            }
        }

        // Parse timestamps with proper timezone handling
        function parseUtcTimestamp(ts) {
            if (!ts) return new Date(NaN);
            
            try {
                // If already contains timezone info, use as is
                if (/[zZ]|[\+\-]\d{2}:?\d{2}$/.test(ts)) {
                    return new Date(ts);
                }
                
                // If no timezone specified, treat as UTC
                if (ts.includes('T') && !ts.includes('Z')) {
                    return new Date(ts + 'Z');
                }
                
                // Fallback to direct parsing
                return new Date(ts);
            } catch (error) {
                console.error('Error parsing timestamp:', ts, error);
                return new Date(NaN);
            }
        }

        // Performance optimization - use LayerGroup for better performance with many markers
        markersLayer = L.layerGroup();

        // Initialize map with performance optimizations
        function initializeMap() {
            if (locations && locations.length > 0) {
                // Calculate center from actual location data efficiently
                var bounds = L.latLngBounds();
                var validLocations = 0;
                
                for (var i = 0; i < locations.length; i++) {
                    var lat = parseFloat(locations[i].latitude);
                    var lng = parseFloat(locations[i].longitude);
                    if (Number.isFinite(lat) && Number.isFinite(lng)) {
                        bounds.extend([lat, lng]);
                        validLocations++;
                    }
                }
                
                if (validLocations > 0) {
                    map = L.map('map', {
                        preferCanvas: true,  // Use Canvas for better performance
                        zoomControl: true,
                        maxZoom: 18
                    }).fitBounds(bounds);
                } else {
                    map = L.map('map', {preferCanvas: true}).setView([39.8283, -98.5795], 4);
                }
            } else {
                // Default to center of US if no location data
                map = L.map('map', {preferCanvas: true}).setView([39.8283, -98.5795], 4);
                
                // Add a message overlay when no data is available
                var noDataDiv = L.control({position: 'topright'});
                noDataDiv.onAdd = function (map) {
                    var div = L.DomUtil.create('div', 'no-data-message');
                    div.innerHTML = '<div style="background: rgba(255,255,255,0.9); padding: 10px; border-radius: 5px; border: 1px solid #ccc; text-align: center;"><i class="fas fa-info-circle text-info"></i> No location data available. Map shows default view.</div>';
                    return div;
                };
                noDataDiv.addTo(map);
            }
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors',
                maxZoom: 18,
                tileSize: 256,
                updateWhenZooming: false,  // Performance optimization
                updateWhenIdle: true
            }).addTo(map);

            // Add markers layer to map
            markersLayer.addTo(map);
        }

        // Group locations by device efficiently
        var deviceLocations = {};
        if (locations && locations.length > 0) {
            for (var i = 0; i < locations.length; i++) {
                var loc = locations[i];
                if (!deviceLocations[loc.device_name]) {
                    deviceLocations[loc.device_name] = [];
                    deviceColors[loc.device_name] = colorPalette[colorIndex % colorPalette.length];
                    colorIndex++;
                }
                deviceLocations[loc.device_name].push(loc);
            }
        }

        // Performance optimized marker and path rendering
        function renderDeviceData() {
            Object.keys(deviceLocations).forEach(function(deviceName) {
                var deviceLocs = deviceLocations[deviceName].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                var deviceColor = deviceColors[deviceName];
                
                // Create path if more than one location
                if (deviceLocs.length > 1) {
                    var pathCoords = [];
                    // Batch coordinate processing
                    for (var i = 0; i < deviceLocs.length; i++) {
                        var lat = parseFloat(deviceLocs[i].latitude);
                        var lng = parseFloat(deviceLocs[i].longitude);
                        if (Number.isFinite(lat) && Number.isFinite(lng)) {
                            pathCoords.push([lat, lng]);
                        }
                    }
                    
                    if (pathCoords.length > 1) {
                        var polyline = L.polyline(pathCoords, {
                            color: deviceColor,
                            weight: 3,
                            opacity: 0.7,
                            dashArray: '5, 5'
                        });
                        polyline.addTo(map);
                        polylines.push(polyline);
                        
                        polyline.bindPopup(`
                            <div class="text-center">
                                <h6><i class="fas fa-route me-1"></i>Movement Path</h6>
                                <p class="mb-1"><strong>${deviceName}</strong></p>
                                <p class="mb-0"><small>${deviceLocs.length} locations tracked</small></p>
                            </div>
                        `);
                    }
                }
                
                // Batch marker creation - only show most important markers for performance
                var markersToShow = [];
                if (deviceLocs.length > 0) {
                    markersToShow.push({loc: deviceLocs[0], type: 'start', index: 0}); // First
                    if (deviceLocs.length > 1) {
                        markersToShow.push({loc: deviceLocs[deviceLocs.length - 1], type: 'end', index: deviceLocs.length - 1}); // Last
                    }
                    
                    // Add middle markers only if we have few locations or user zooms in
                    if (deviceLocs.length <= 20) {
                        for (var i = 1; i < deviceLocs.length - 1; i++) {
                            markersToShow.push({loc: deviceLocs[i], type: 'middle', index: i});
                        }
                    }
                }
                
                // Batch create markers
                markersToShow.forEach(function(markerInfo) {
                    var loc = markerInfo.loc;
                    var index = markerInfo.index;
                var isFirst = index === 0;
                var isLast = index === deviceLocs.length - 1;
                var isMiddle = !isFirst && !isLast;
                
                var markerColor = deviceColor;
                var iconHtml = '';
                var title = '';
                
                if (isFirst) {
                    iconHtml = `<div style="background-color: ${markerColor}; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center;"><i class="fas fa-play" style="color: white; font-size: 8px;"></i></div>`;
                    title = 'Start Location';
                } else if (isLast) {
                    iconHtml = `<div style="background-color: ${markerColor}; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center;"><i class="fas fa-stop" style="color: white; font-size: 8px;"></i></div>`;
                    title = 'Latest Location';
                } else {
                    iconHtml = `<div style="background-color: ${markerColor}; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 3px rgba(0,0,0,0.3); opacity: 0.8;"></div>`;
                    title = 'Movement Point';
                }
                
                var customIcon = L.divIcon({
                    className: 'custom-marker',
                    html: iconHtml,
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                });
                
                    var latNum = parseFloat(loc.latitude);
                    var lngNum = parseFloat(loc.longitude);
                    if (!Number.isFinite(latNum) || !Number.isFinite(lngNum)) return;
                    
                    var marker = L.marker([latNum, lngNum], { icon: customIcon })
                        .bindPopup(`
                            <div class="text-center">
                                <h6><i class="fas fa-mobile-alt me-1"></i>${loc.device_name}</h6>
                                <p class="mb-1" style="color: ${markerColor}"><strong>${title}</strong></p>
                                <p class="mb-1">${Number(latNum).toFixed(6)}, ${Number(lngNum).toFixed(6)}</p>
                                <p class="mb-0"><small>${formatTimestampForUser(loc.timestamp)}</small></p>
                                ${index > 0 ? `<hr class="my-2"><small class="text-muted">Point ${index + 1} of ${deviceLocs.length}</small>` : ''}
                            </div>
                        `);
                    
                    // Add to markers layer for better performance
                    markersLayer.addLayer(marker);
                    markers.push(marker);
                });
            });
        }

        // Lazy loading initialization when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize map first
            try {
                initializeMap();
            } catch (e) {
                console.error('Map initialization failed:', e);
            }
            
            // Then render data with a slight delay for better UX
            setTimeout(function() {
                renderDeviceData();
                
                // Fit map to show all markers if any exist
                if (markers.length > 0) {
                    var group = new L.featureGroup(markers);
                    map.fitBounds(group.getBounds().pad(0.1));
                }
                
                // Update visit tabs
                try {
                    updateVisitTabs();
                } catch (e) {
                    console.warn('Visit tab update failed:', e);
                }

                // Update recent address display for each tracked device
                try {
                    updateDeviceAddresses();
                } catch (e) {
                    console.warn('Device address update failed:', e);
                }
            }, 100); // 100ms delay for better UX
        });

        // Helper functions for date controls
        function setYesterday() {
            var yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            document.getElementById('date').value = yesterday.toISOString().split('T')[0];
        }

        // Set max date to today
        (function(){
            var dateEl = document.getElementById('date');
            if (dateEl) {
                dateEl.max = new Date().toISOString().split('T')[0];
            }
        })();

        // Update statistics
        function updateStats() {
            fetch('/api/stats')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('total-locations').textContent = data.total_locations;
                    document.getElementById('unique-devices').textContent = data.unique_devices;
                    document.getElementById('today-count').textContent = data.today_count;
                    if (data.last_update) {
                        document.getElementById('last-update').textContent = data.last_update.substring(0, 10);
                    }
                })
                .catch(error => console.error('Error updating stats:', error));
        }

        // Auto-refresh functionality
        function refreshData() {
            var selectedDate = "{{ selected_date or '' }}";
            var selectedDevice = "{{ selected_device or '' }}";

            // Build query for last 24h or selected date window
            var params = new URLSearchParams();
            if (selectedDevice) params.set('device', selectedDevice);
            if (selectedDate) {
                // 00:00:00 to 23:59:59 of selected date
                var start = new Date(selectedDate + 'T00:00:00');
                var end = new Date(selectedDate + 'T23:59:59');
                params.set('start', start.toISOString());
                params.set('end', end.toISOString());
                params.set('limit', '20000');
            } else {
                // last 24 hours
                var endNow = new Date();
                var start24h = new Date(endNow.getTime() - 24*60*60*1000);
                params.set('start', start24h.toISOString());
                params.set('end', endNow.toISOString());
                params.set('limit', '20000');
            }

            fetch('/api/locations?' + params.toString())
                .then(response => response.json())
                .then(data => {
                    // Clear existing markers and polylines
                    markers.forEach(marker => markersLayer.removeLayer(marker));
                    markers = [];
                    polylines.forEach(line => map.removeLayer(line));
                    polylines = [];

                    // Update global locations data with new data
                    locations = data;
                    
                    // Rebuild device grouping
                    deviceLocations = {};
                    deviceColors = {};
                    colorIndex = 0;
                    
                    if (locations && locations.length > 0) {
                        for (var i = 0; i < locations.length; i++) {
                            var loc = locations[i];
                            if (!deviceLocations[loc.device_name]) {
                                deviceLocations[loc.device_name] = [];
                                deviceColors[loc.device_name] = colorPalette[colorIndex % colorPalette.length];
                                colorIndex++;
                            }
                            deviceLocations[loc.device_name].push(loc);
                        }
                    }

                    // Re-render all device data using existing function
                    renderDeviceData();

                    if (markers.length > 0) {
                        var group = new L.featureGroup(markers);
                        map.fitBounds(group.getBounds().pad(0.1));
                    } else {
                        map.setView([39.8283, -98.5795], 4);
                    }

                    // Update visit tabs with new data
                    updateVisitTabs();

                    // Update statistics
                    updateStats();
                })
                .catch(error => console.error('Error refreshing data:', error));
        }

        // Auto-refresh every 5 minutes
        setInterval(refreshData, 300000);

        // Update stats every minute
        setInterval(updateStats, 60000);

        // Form validation (guarded)
        (function() {
            var movementForm = document.getElementById('movementForm');
            if (!movementForm) return;
            movementForm.addEventListener('submit', function(e) {
                var startEl = document.getElementById('start');
                var endEl = document.getElementById('end');
                if (!startEl || !endEl) return;
                var start = startEl.value;
                var end = endEl.value;
                if (start && end && new Date(start) >= new Date(end)) {
                    e.preventDefault();
                    alert('End time must be after start time.');
                }
            });
        })();
        
        // Notification System JavaScript
        let notificationCount = 0;
        const csrf_token = "{{ csrf_token() }}";

        // Load notification count
        async function loadNotificationCount() {
            try {
                const response = await fetch('/api/notifications/count');
                const result = await response.json();
                
                if (result.success) {
                    updateNotificationBadge(result.unread_count);
                }
            } catch (error) {
                console.error('Error loading notification count:', error);
            }
        }

        // Update notification badge
        function updateNotificationBadge(count) {
            const badge = document.getElementById('notificationBadge');
            if (count > 0) {
                badge.textContent = count;
                badge.style.display = 'inline-block';
                if (count > notificationCount) {
                    badge.classList.add('notification-badge-animate');
                    setTimeout(() => badge.classList.remove('notification-badge-animate'), 500);
                }
            } else {
                badge.style.display = 'none';
            }
            notificationCount = count;
        }

        // Load notifications
        async function loadNotifications(unreadOnly = true) {
            try {
                const response = await fetch(`/api/notifications?unread_only=${unreadOnly}&limit=10`);
                const result = await response.json();
                
                if (result.success) {
                    displayNotifications(result.notifications);
                }
            } catch (error) {
                console.error('Error loading notifications:', error);
            }
        }

        // Display notifications in dropdown
        function displayNotifications(notifications) {
            const notificationList = document.getElementById('notificationList');
            
            if (notifications.length === 0) {
                notificationList.innerHTML = `
                    <div class="dropdown-item-text text-center text-muted py-4">
                        <i class="fas fa-bell-slash fa-2x mb-2"></i><br>
                        No notifications
                    </div>
                `;
                return;
            }

            let html = '';
            notifications.forEach(notification => {
                const timeAgo = getTimeAgo(new Date(notification.timestamp));
                const isUnread = !notification.is_read;
                const priorityClass = `priority-${notification.priority}`;
                const typeClass = `notification-${notification.notification_type}`;
                
                html += `
                    <div class="notification-item ${isUnread ? 'unread' : 'read'} ${priorityClass} ${typeClass}"
                         onclick="markNotificationRead(${notification.id})"
                         data-notification-id="${notification.id}">
                        <div class="d-flex justify-content-between">
                            <div class="flex-grow-1">
                                <div class="d-flex align-items-center mb-1">
                                    <i class="fas fa-${getNotificationIcon(notification.notification_type, notification.event_type)} me-2"></i>
                                    <strong>${notification.device_name}</strong>
                                    ${isUnread ? '<span class="badge bg-primary ms-2">New</span>' : ''}
                                </div>
                                <p class="mb-1">${notification.message}</p>
                                <small class="text-muted">
                                    <i class="fas fa-clock me-1"></i>${timeAgo}
                                    ${notification.geofence_name ? `â€¢ <i class="fas fa-map-marker-alt me-1"></i>${notification.geofence_name}` : ''}
                                </small>
                            </div>
                        </div>
                    </div>
                `;
            });

            notificationList.innerHTML = html;
        }

        // Get notification icon based on type and event
        function getNotificationIcon(type, event) {
            switch(type) {
                case 'geofence':
                    return event === 'entry' ? 'sign-in-alt' : event === 'exit' ? 'sign-out-alt' : 'map-marker-alt';
                case 'device':
                    return 'mobile-alt';
                case 'system':
                    return 'cog';
                default:
                    return 'bell';
            }
        }

        // Calculate time ago
        function getTimeAgo(date) {
            const now = new Date();
            const diff = Math.floor((now - date) / 1000);
            
            if (diff < 60) return 'Just now';
            if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
            if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
            return `${Math.floor(diff / 86400)}d ago`;
        }

        // Mark notification as read
        async function markNotificationRead(notificationId) {
            try {
                const response = await fetch(`/api/notifications/${notificationId}/read`, {
                    method: 'PUT',
                    headers: {
                        'X-CSRFToken': csrf_token
                    }
                });

                if (response.ok) {
                    // Update UI
                    const notificationItem = document.querySelector(`[data-notification-id="${notificationId}"]`);
                    if (notificationItem) {
                        notificationItem.classList.remove('unread');
                        notificationItem.classList.add('read');
                        const newBadge = notificationItem.querySelector('.badge');
                        if (newBadge) newBadge.remove();
                    }
                    
                    // Update count
                    loadNotificationCount();
                }
            } catch (error) {
                console.error('Error marking notification as read:', error);
            }
        }

        // Mark all notifications as read
        async function markAllNotificationsRead() {
            try {
                const response = await fetch('/api/notifications/mark-all-read', {
                    method: 'PUT',
                    headers: {
                        'X-CSRFToken': csrf_token
                    }
                });

                if (response.ok) {
                    // Reload notifications and count
                    loadNotifications();
                    loadNotificationCount();
                }
            } catch (error) {
                console.error('Error marking all notifications as read:', error);
            }
        }

        // Load all notifications (for future full notifications page)
        function loadAllNotifications() {
            // TODO: Navigate to full notifications page
            alert('Full notifications page coming soon!');
        }

        // Visit Analysis Functions
        function analyzeVisitData(locations) {
            if (!locations || locations.length === 0) {
                return {};
            }
            
            // Group locations by device
            const deviceLocations = {};
            locations.forEach(loc => {
                const deviceName = loc.device_name;
                if (!deviceLocations[deviceName]) {
                    deviceLocations[deviceName] = [];
                }
                deviceLocations[deviceName].push({
                    ...loc,
                    timestamp: parseUtcTimestamp(loc.timestamp),
                    latitude: parseFloat(loc.latitude),
                    longitude: parseFloat(loc.longitude)
                });
            });
            
            // Analyze visits for each device
            const deviceVisits = {};
            Object.keys(deviceLocations).forEach(deviceName => {
                deviceVisits[deviceName] = analyzeDeviceVisits(deviceLocations[deviceName]);
            });
            
            return deviceVisits;
        }
        
        function analyzeDeviceVisits(deviceLocs) {
            if (!deviceLocs || deviceLocs.length === 0) return [];
            
            console.log(`ðŸ“ Analyzing ${deviceLocs.length} locations for device`);
            
            // Sort by timestamp
            deviceLocs.sort((a, b) => a.timestamp - b.timestamp);
            
            // Step 1: Cluster locations by coordinates to identify distinct places
            const locationClusters = clusterLocationsByCoordinates(deviceLocs);
            console.log(`ðŸ—ºï¸ Found ${locationClusters.length} distinct location clusters`);
            
            const activities = [];
            
            // Step 2: Analyze each cluster for visits and drives
            for (let i = 0; i < deviceLocs.length; i++) {
                const loc = deviceLocs[i];
                const cluster = findClusterForLocation(loc, locationClusters);
                loc.clusterId = cluster.id;
                loc.clusterCenter = cluster.center;
            }
            
            // Step 3: Group consecutive points by cluster and create visits/drives
            let currentSegment = null;
            let lastProcessedSegment = null;
            
            for (let i = 0; i < deviceLocs.length; i++) {
                const loc = deviceLocs[i];
                
                if (!currentSegment || currentSegment.clusterId !== loc.clusterId) {
                    // Finish previous segment
                    if (currentSegment) {
                        const segmentActivities = processSegment(currentSegment);
                        activities.push(...segmentActivities);
                        
                        // Check if we need to create a drive between segments
                        if (lastProcessedSegment && lastProcessedSegment.clusterId !== currentSegment.clusterId) {
                            const drive = createDriveBetweenSegments(lastProcessedSegment, currentSegment);
                            if (drive) {
                                activities.push(drive);
                            }
                        }
                        
                        lastProcessedSegment = currentSegment;
                    }
                    
                    // Start new segment
                    currentSegment = {
                        clusterId: loc.clusterId,
                        clusterCenter: loc.clusterCenter,
                        locations: [loc],
                        startTime: loc.timestamp,
                        endTime: loc.timestamp
                    };
                } else {
                    // Extend current segment
                    currentSegment.locations.push(loc);
                    currentSegment.endTime = loc.timestamp;
                }
            }
            
            // Process final segment
            if (currentSegment) {
                const segmentActivities = processSegment(currentSegment);
                activities.push(...segmentActivities);
                
                // Check if we need to create a drive between segments
                if (lastProcessedSegment && lastProcessedSegment.clusterId !== currentSegment.clusterId) {
                    const drive = createDriveBetweenSegments(lastProcessedSegment, currentSegment);
                    if (drive) {
                        activities.push(drive);
                    }
                }
            }
            
            // Sort activities by start time
            activities.sort((a, b) => {
                const aTime = a.type === 'visit' ? a.arrival : a.start_time;
                const bTime = b.type === 'visit' ? b.arrival : b.start_time;
                return aTime - bTime;
            });
            
            console.log(`ðŸ“Š Created ${activities.filter(a => a.type === 'visit').length} visits and ${activities.filter(a => a.type === 'drive').length} drives`);
            return activities;
        }
        
        function clusterLocationsByCoordinates(locations) {
            const clusters = [];
            const CLUSTER_THRESHOLD = 0.002; // ~200m clustering radius (reduced for better visit detection)
            const JITTER_THRESHOLD = 0.0003; // ~33m jitter smoothing (reduced for better precision)
            
            for (const loc of locations) {
                let assignedCluster = null;
                
                // Find nearest cluster
                for (const cluster of clusters) {
                    const distance = calculateDistance(
                        loc.latitude, loc.longitude,
                        cluster.center.lat, cluster.center.lng
                    );
                    
                    if (distance < CLUSTER_THRESHOLD || distance < JITTER_THRESHOLD) {
                        assignedCluster = cluster;
                        break;
                    }
                }
                
                if (assignedCluster) {
                    // Add to existing cluster and update center
                    assignedCluster.locations.push(loc);
                    const lats = assignedCluster.locations.map(l => l.latitude);
                    const lngs = assignedCluster.locations.map(l => l.longitude);
                    assignedCluster.center = {
                        lat: lats.reduce((a, b) => a + b, 0) / lats.length,
                        lng: lngs.reduce((a, b) => a + b, 0) / lngs.length
                    };
                } else {
                    // Create new cluster
                    clusters.push({
                        id: clusters.length,
                        center: { lat: loc.latitude, lng: loc.longitude },
                        locations: [loc]
                    });
                }
            }
            
            return clusters;
        }
        
        function findClusterForLocation(location, clusters) {
            const CLUSTER_THRESHOLD = 0.002;
            
            for (const cluster of clusters) {
                const distance = calculateDistance(
                    location.latitude, location.longitude,
                    cluster.center.lat, cluster.center.lng
                );
                
                if (distance < CLUSTER_THRESHOLD) {
                    return cluster;
                }
            }
            
            // Shouldn't happen, but fallback
            return clusters[0];
        }
        
        function processSegment(segment) {
            const activities = [];
            const durationMinutes = (segment.endTime - segment.startTime) / (1000 * 60);
            
            // If segment is at a location for >= 5 minutes, it's a visit (reduced from 15 minutes)
            if (durationMinutes >= 5) {
                activities.push({
                    type: 'visit',
                    latitude: segment.clusterCenter.lat,
                    longitude: segment.clusterCenter.lng,
                    arrival: segment.startTime,
                    departure: segment.endTime,
                    duration_minutes: Math.round(durationMinutes),
                    location_count: segment.locations.length,
                    address: null
                });
                
                console.log(`âœ… VISIT: ${Math.round(durationMinutes)} minutes at cluster ${segment.clusterId}`);
            }
            
            return activities;
        }
        
        function createDriveBetweenSegments(fromSegment, toSegment) {
            // Only create drives between different clusters
            if (fromSegment.clusterId === toSegment.clusterId) {
                return null;
            }
            
            const distanceKm = calculateDistanceKm(
                fromSegment.clusterCenter.lat, fromSegment.clusterCenter.lng,
                toSegment.clusterCenter.lat, toSegment.clusterCenter.lng
            );
            
            // Only create drives for meaningful distances (>0.5km)
            if (distanceKm < 0.5) {
                return null;
            }
            
            const durationMinutes = (toSegment.startTime - fromSegment.endTime) / (1000 * 60);
            if (!Number.isFinite(durationMinutes) || durationMinutes <= 0) {
                return null;
            }
            const avgSpeedKmh = durationMinutes > 0 ? (distanceKm / (durationMinutes / 60)) : 0;
            
            // Filter out impossible speeds (>200 km/h)
            if (avgSpeedKmh > 200) {
                console.log(`ðŸš« REJECTED DRIVE: ${avgSpeedKmh.toFixed(1)} km/h too fast`);
                return null;
            }
            
            console.log(`ðŸš— DRIVE: ${distanceKm.toFixed(2)}km, ${avgSpeedKmh.toFixed(1)} km/h, ${durationMinutes.toFixed(1)} min`);
            
            // Normalize to UI schema (type 'driving' and expected fields)
            return {
                type: 'driving',
                from_latitude: fromSegment.clusterCenter.lat,
                from_longitude: fromSegment.clusterCenter.lng,
                to_latitude: toSegment.clusterCenter.lat,
                to_longitude: toSegment.clusterCenter.lng,
                departure: fromSegment.endTime,
                arrival: toSegment.startTime,
                duration_minutes: Math.round(durationMinutes),
                distance_km: parseFloat(distanceKm.toFixed(2)),
                distance_miles: parseFloat((distanceKm * 0.621371).toFixed(1)),
                average_speed_kmh: parseFloat(avgSpeedKmh.toFixed(1)),
                actual_route: false,
                estimated_duration_minutes: Math.round(durationMinutes),
                route_pending: true
            };
        }
        
        function calculateDistance(lat1, lng1, lat2, lng2) {
            // Simple Euclidean distance for clustering (good enough for short distances)
            const latDiff = lat1 - lat2;
            const lngDiff = lng1 - lng2;
            return Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
        }
        
        function calculateDistanceKm(lat1, lng1, lat2, lng2) {
            // Haversine formula for accurate distance in kilometers
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        async function createDrivingSegment(fromCluster, toCluster) {
            const timeDiffMs = toCluster.arrival - fromCluster.departure;
            const timeDiffMinutes = Math.round(timeDiffMs / (1000 * 60));
            
            // Try to get actual route data
            const routeData = await getRouteData(
                fromCluster.latitude, fromCluster.longitude,
                toCluster.latitude, toCluster.longitude
            );
            
            let distanceKm, distanceMiles, estimatedDuration;
            
            if (routeData && routeData.distance) {
                // Use actual route distance
                distanceKm = routeData.distance / 1000; // Convert meters to km
                distanceMiles = distanceKm * 0.621371;
                estimatedDuration = Math.round(routeData.duration / 60); // Convert seconds to minutes
            } else {
                // Fallback to straight-line distance
                console.warn('Route data not available, using straight-line distance');
                distanceKm = calculateDistanceKm(
                    fromCluster.latitude, fromCluster.longitude,
                    toCluster.latitude, toCluster.longitude
                );
                distanceMiles = distanceKm * 0.621371;
                estimatedDuration = timeDiffMinutes;
            }
            
            return {
                type: 'driving',
                from_latitude: fromCluster.latitude,
                from_longitude: fromCluster.longitude,
                to_latitude: toCluster.latitude,
                to_longitude: toCluster.longitude,
                departure: fromCluster.departure,
                arrival: toCluster.arrival,
                distance_km: Math.round(distanceKm * 10) / 10,
                distance_miles: Math.round(distanceMiles * 10) / 10,
                duration_minutes: timeDiffMinutes,
                estimated_duration_minutes: estimatedDuration,
                actual_route: routeData ? true : false,
                from_address: null,
                to_address: null
            };
        }
        
        async function getRouteData(fromLat, fromLng, toLat, toLng) {
            try {
                // Use OpenRouteService API (free, no API key required for basic usage)
                const url = `https://api.openrouteservice.org/v2/directions/driving-car?start=${fromLng},${fromLat}&end=${toLng},${toLat}`;
                
                const response = await fetch(url, {
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    timeout: 5000 // 5 second timeout
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.features && data.features.length > 0) {
                    const route = data.features[0];
                    const distance = route.properties.segments[0].distance; // meters
                    const duration = route.properties.segments[0].duration; // seconds
                    
                    return {
                        distance: distance,
                        duration: duration,
                        geometry: route.geometry // GeoJSON LineString for route path
                    };
                }
                
                return null;
            } catch (error) {
                console.warn('OpenRouteService failed, trying fallback:', error);
                return await getRouteDataFallback(fromLat, fromLng, toLat, toLng);
            }
        }
        
        async function getRouteDataFallback(fromLat, fromLng, toLat, toLng) {
            try {
                // Fallback to OSRM (Open Source Routing Machine)
                const url = `https://router.project-osrm.org/route/v1/driving/${fromLng},${fromLat};${toLng},${toLat}?overview=false&steps=false`;
                
                const response = await fetch(url, {
                    timeout: 3000 // 3 second timeout for fallback
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.routes && data.routes.length > 0) {
                    const route = data.routes[0];
                    return {
                        distance: route.distance, // meters
                        duration: route.duration, // seconds
                        geometry: null // OSRM geometry not needed for basic distance/time
                    };
                }
                
                return null;
            } catch (error) {
                console.warn('All routing services failed:', error);
                return null;
            }
        }
        
        function finalizeVisit(visit) {
            const durationMs = visit.departure - visit.arrival;
            const durationMinutes = Math.round(durationMs / (1000 * 60));
            
            return {
                latitude: visit.latitude,
                longitude: visit.longitude,
                arrival: visit.arrival,
                departure: visit.departure,
                duration_minutes: durationMinutes,
                location_count: visit.locations.length,
                address: null // Will be populated by getAddressForVisit
            };
        }
        
        async function getAddressForVisit(latitude, longitude) {
            try {
                // Try to get cached address first
                const response = await fetch(`/api/address?lat=${latitude}&lng=${longitude}`);
                if (response.ok) {
                    const data = await response.json();
                    return data.address || `Location (${latitude.toFixed(4)}, ${longitude.toFixed(4)})`;
                }
            } catch (error) {
                console.warn('Error fetching address:', error);
            }
            
            // Fallback to coordinates
            return `Location (${latitude.toFixed(4)}, ${longitude.toFixed(4)})`;
        }
        
        function formatDuration(minutes) {
            if (minutes < 60) {
                return `${minutes}m`;
            } else {
                const hours = Math.floor(minutes / 60);
                const mins = minutes % 60;
                return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
            }
        }
        
        async function updateVisitTabs() {
            const deviceVisits = analyzeVisitData(locations || []);
            const deviceNames = Object.keys(deviceVisits);
            
            // Debug logging
            console.log('Total locations:', locations.length);
            console.log('Device visits:', deviceVisits);
            deviceNames.forEach(device => {
                const activities = deviceVisits[device];
                const visits = activities.filter(a => a.type === 'visit');
                const drives = activities.filter(a => a.type === 'driving');
                console.log(`${device}: ${visits.length} visits, ${drives.length} drives`);
            });
            
            const tabsContainer = document.getElementById('deviceTabs');
            const contentContainer = document.getElementById('deviceTabContent');
            const noDataDiv = document.getElementById('noVisitData');
            if (!tabsContainer || !contentContainer) {
                console.warn('Visit tabs containers not found in DOM');
                return;
            }
            
            if (!deviceNames || deviceNames.length === 0) {
                tabsContainer.innerHTML = '';
                contentContainer.innerHTML = '';
                noDataDiv.style.display = 'block';
                return;
            }
            
            noDataDiv.style.display = 'none';
            
            // Generate tabs
            let tabsHtml = '';
            let contentHtml = '';
            
            for (let i = 0; i < deviceNames.length; i++) {
                const deviceName = deviceNames[i];
                const activities = deviceVisits[deviceName];
                const visitCount = activities.filter(a => a.type === 'visit').length;
                const drivingCount = activities.filter(a => a.type === 'driving').length;
                const isActive = i === 0 ? 'active' : '';
                const isSelected = i === 0 ? 'true' : 'false';
                const tabId = `device-tab-${deviceName.replace(/[^a-zA-Z0-9]/g, '-')}`;
                const contentId = `device-content-${deviceName.replace(/[^a-zA-Z0-9]/g, '-')}`;
                
                // Only show badge if there are activities
                const badgeHtml = (visitCount > 0 || drivingCount > 0) ? 
                    `<span class="badge ms-2">${visitCount}v ${drivingCount}d</span>` : '';
                
                // Tab navigation item
                tabsHtml += `
                    <li class="nav-item" role="presentation">
                        <button class="nav-link ${isActive}" id="${tabId}" data-bs-toggle="tab" 
                                data-bs-target="#${contentId}" type="button" role="tab" 
                                aria-controls="${contentId}" aria-selected="${isSelected}">
                            <i class="fas fa-mobile-alt me-1"></i>${deviceName}
                            ${badgeHtml}
                        </button>
                    </li>
                `;
                
                // Tab content
                contentHtml += `
                    <div class="tab-pane fade ${isActive} show" id="${contentId}" role="tabpanel" aria-labelledby="${tabId}">
                        <div id="visits-${contentId}">
                            <div class="text-center py-3">
                                <div class="spinner-border spinner-border-sm" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                                <p class="mt-2 mb-0">Loading visit details...</p>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            tabsContainer.innerHTML = tabsHtml;
            contentContainer.innerHTML = contentHtml;
            
            // Populate visit details for each device (sequential to avoid UI thrash)
            for (const deviceName of deviceNames) {
                await populateVisitDetails(deviceName, deviceVisits[deviceName] || []);
            }
        }
        
        async function populateVisitDetails(deviceName, activities) {
            const safeName = deviceName.replace(/[^a-zA-Z0-9]/g, '-');
            const contentId = `device-content-${safeName}`;
            const visitsContainer = document.getElementById(`visits-${contentId}`);
            
            if (activities.length === 0) {
                visitsContainer.innerHTML = `
                    <div class="text-center text-muted py-4">
                        <i class="fas fa-map-marker-alt fa-2x mb-2"></i>
                        <p>No activities found for ${deviceName}</p>
                        <small>Activities include visits (2+ minutes) and driving segments</small>
                    </div>
                `;
                return;
            }
            
            let activitiesHtml = '';
            
            // Sort activities by time
            activities.sort((a, b) => {
                const timeA = a.type === 'visit' ? a.arrival : a.departure;
                const timeB = b.type === 'visit' ? b.arrival : b.departure;
                return timeA - timeB;
            });
            
            // Process activities and get addresses - show immediate results
            await populateVisitDetailsContent(activities, visitsContainer);
            
            // Update driving segments with actual route data in background
            updateDrivingSegmentsWithRouteData(activities).then(() => {
                console.log('Route data updated, re-rendering...');
                populateVisitDetailsContent(activities, visitsContainer);
            }).catch(error => {
                console.warn('Route data update failed:', error);
            });
        }
        
        async function populateVisitDetailsContent(activities, visitsContainer) {
            console.log('populateVisitDetailsContent called with', activities.length, 'activities');
            let activitiesHtml = '';
            
            if (activities.length === 0) {
                visitsContainer.innerHTML = `
                    <div class="text-center text-muted py-4">
                        <i class="fas fa-map-marker-alt fa-2x mb-2"></i>
                        <p>No activities found</p>
                        <small>Activities include visits (2+ minutes) and driving segments</small>
                    </div>
                `;
                return;
            }
            
            // Process activities and get addresses
            for (let i = 0; i < activities.length; i++) {
                const activity = activities[i];
                console.log(`Processing activity ${i+1}/${activities.length}:`, activity.type);
                
                if (activity.type === 'visit') {
                    // Get address for this visit
                    const address = await getAddressForVisit(activity.latitude, activity.longitude);
                    
                    const arrivalTime = formatTimestampForUser(activity.arrival.toISOString());
                    const departureTime = formatTimestampForUser(activity.departure.toISOString());
                    const duration = formatDuration(activity.duration_minutes);
                    
                    activitiesHtml += `
                        <div class="visit-item" onclick="centerMapOnLocation(${activity.latitude}, ${activity.longitude})">
                            <div class="visit-location">
                                <i class="fas fa-map-marker-alt me-2 text-primary"></i>
                                ${address}
                            </div>
                            <div class="visit-times">
                                <div class="visit-time-item arrival">
                                    <i class="fas fa-sign-in-alt"></i>
                                    Arrived: ${arrivalTime}
                                </div>
                                <div class="visit-time-item departure">
                                    <i class="fas fa-sign-out-alt"></i>
                                    Left: ${departureTime}
                                </div>
                                <div class="visit-time-item duration">
                                    <i class="fas fa-clock"></i>
                                    Duration: ${duration}
                                </div>
                            </div>
                            <div class="visit-coordinates">
                                ${activity.latitude.toFixed(6)}, ${activity.longitude.toFixed(6)} 
                                â€¢ ${activity.location_count} location points
                            </div>
                        </div>
                    `;
                } else if (activity.type === 'driving') {
                    // Get addresses for driving segment
                    const fromAddress = await getAddressForVisit(activity.from_latitude, activity.from_longitude);
                    const toAddress = await getAddressForVisit(activity.to_latitude, activity.to_longitude);
                    
                    const startTime = formatTimestampForUser(activity.departure.toISOString());
                    const endTime = formatTimestampForUser(activity.arrival.toISOString());
                    const duration = formatDuration(activity.duration_minutes);
                    
                    // Simplify addresses for driving display
                    const fromSimple = simplifyAddress(fromAddress);
                    const toSimple = simplifyAddress(toAddress);
                    
                    const actualSpeed = calculateAverageSpeed(activity.distance_miles, activity.duration_minutes);
                    const estimatedSpeed = activity.estimated_duration_minutes ? 
                        calculateAverageSpeed(activity.distance_miles, activity.estimated_duration_minutes) : null;
                    
                    // Determine route accuracy indicator
                    const routeIndicator = activity.actual_route ? 
                        '<i class="fas fa-check-circle text-success" title="Actual road route"></i>' :
                        '<i class="fas fa-ruler text-warning" title="Estimated route"></i>';
                    
                    activitiesHtml += `
                        <div class="driving-segment">
                            <div class="driving-icon">
                                <i class="fas fa-car"></i>
                            </div>
                            <div class="driving-details">
                                <div class="driving-route">
                                    Drove from <strong>${fromSimple}</strong> to <strong>${toSimple}</strong>
                                    ${routeIndicator}
                                </div>
                                <div class="driving-stats">
                                    <div class="driving-stat">
                                        <i class="fas fa-play"></i>
                                        Started: ${startTime}
                                    </div>
                                    <div class="driving-stat">
                                        <i class="fas fa-stop"></i>
                                        Arrived: ${endTime}
                                    </div>
                                    <div class="driving-stat">
                                        <i class="fas fa-route"></i>
                                        ${activity.distance_miles} mi${activity.actual_route ? ' (road)' : ' (est.)'}
                                    </div>
                                    <div class="driving-stat">
                                        <i class="fas fa-clock"></i>
                                        ${duration} total
                                    </div>
                                    <div class="driving-stat">
                                        <i class="fas fa-tachometer-alt"></i>
                                        ${actualSpeed} mph avg
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }
            }
            
            visitsContainer.innerHTML = activitiesHtml;
        }
        
        async function updateDrivingSegmentsWithRouteData(activities) {
            const drivingSegments = activities.filter(a => a.type === 'driving' && a.route_pending);
            
            console.log(`Updating ${drivingSegments.length} driving segments with route data...`);
            
            // Process driving segments in parallel (but limit concurrent requests)
            const batchSize = 3; // Process 3 routes at a time to avoid overwhelming APIs
            for (let i = 0; i < drivingSegments.length; i += batchSize) {
                const batch = drivingSegments.slice(i, i + batchSize);
                
                await Promise.all(batch.map(async (segment) => {
                    try {
                        const routeData = await getRouteData(
                            segment.from_latitude, segment.from_longitude,
                            segment.to_latitude, segment.to_longitude
                        );
                        
                        if (routeData && routeData.distance) {
                            // Update with actual route data
                            segment.distance_km = Math.round((routeData.distance / 1000) * 10) / 10;
                            segment.distance_miles = Math.round(segment.distance_km * 0.621371 * 10) / 10;
                            segment.estimated_duration_minutes = Math.round(routeData.duration / 60);
                            segment.actual_route = true;
                            segment.route_pending = false;
                            
                            console.log(`Updated route: ${segment.distance_miles} mi (was ${Math.round(calculateDistanceKm(segment.from_latitude, segment.from_longitude, segment.to_latitude, segment.to_longitude) * 0.621371 * 10) / 10} mi straight-line)`);
                        } else {
                            // Keep straight-line data but mark as estimated
                            segment.route_pending = false;
                            segment.actual_route = false;
                        }
                    } catch (error) {
                        console.warn('Failed to get route data for segment:', error);
                        segment.route_pending = false;
                        segment.actual_route = false;
                    }
                }));
                
                // Small delay between batches to be nice to the APIs
                if (i + batchSize < drivingSegments.length) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
        }
        
        function simplifyAddress(fullAddress) {
            if (!fullAddress || fullAddress.includes('Location (')) {
                return 'Unknown Location';
            }
            
            // Extract meaningful parts - take first part before comma, or city name
            const parts = fullAddress.split(',');
            if (parts.length >= 2) {
                // Try to get street name and city
                const street = parts[0].trim();
                const city = parts[1].trim();
                
                // If street is too long, just use city
                if (street.length > 25) {
                    return city;
                }
                return `${street}, ${city}`;
            }
            
            return parts[0].trim();
        }
        
        function calculateAverageSpeed(distanceMiles, durationMinutes) {
            if (durationMinutes <= 0) return 0;
            const speedMph = (distanceMiles / durationMinutes) * 60;
            return Math.round(speedMph);
        }
        
        function centerMapOnLocation(latitude, longitude) {
            if (map) {
                map.setView([latitude, longitude], 16);
                
                // Find and open popup for this location if it exists
                markersLayer.eachLayer(function(marker) {
                    const markerPos = marker.getLatLng();
                    const distance = Math.abs(markerPos.lat - latitude) + Math.abs(markerPos.lng - longitude);
                    if (distance < 0.001) { // Close enough
                        marker.openPopup();
                    }
                });
            }
        }

        // Fill most recent address beneath tracked devices
        async function updateDeviceAddresses() {
            if (!locations || locations.length === 0) return;

            const latestByDevice = new Map();
            for (const loc of locations) {
                const ts = parseUtcTimestamp(loc.timestamp);
                const prev = latestByDevice.get(loc.device_name);
                if (!prev || ts > prev.ts) {
                    latestByDevice.set(loc.device_name, { ts, lat: parseFloat(loc.latitude), lng: parseFloat(loc.longitude) });
                }
            }

            for (const [name, data] of latestByDevice.entries()) {
                const elId = `device-addr-${name.replace(/\s/g, '-').replace(/\./g, '-').replace(/'/g, '-').replace(/\//g, '-')}`;
                const el = document.getElementById(elId);
                if (!el) continue;

                let address = `${data.lat.toFixed(4)}, ${data.lng.toFixed(4)}`;
                try {
                    const res = await fetch(`/api/address?lat=${data.lat}&lng=${data.lng}`);
                    if (res.ok) {
                        const j = await res.json();
                        if (j && j.address) address = j.address;
                    }
                } catch (_) {}

                el.innerHTML = `<i class="fas fa-map-marker-alt me-1"></i>${address}`;
            }
        }

        // Notification system is handled globally via static/js/notifications.js
    </script>
{% endblock %}